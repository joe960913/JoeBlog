<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>React生命周期总结</title><link rel="shortcut icon" href="/images/ghost.jpg"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script><meta name="generator" content="Hexo 4.0.0"></head><body><nav class="main-nav"><a href="/">Home</a><a href="/archives">Archives</a><a href="/about">About Me</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/"><img class="2x" id="avatar" src="/images/ghost.jpg"></a><h1>Redamancy_13</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>React生命周期总结</h1><h2 class="headline">Aug 09, 2018 10:36·
856 words
·
3 minutes read<span class="tags"></span></h2></header><section id="post-body"><h1 id="render"><a href="#render" class="headerlink" title="render( )"></a>render( )</h1><p><code>render()</code> 方法是 class 组件中唯一必须实现的方法。</p>
<p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p>
<ul>
<li><strong>React 元素</strong>。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li>
<li><strong>字符串或数值类型</strong>。它们在 DOM 中会被渲染为文本节点</li>
<li><strong>布尔类型或 <code>null</code></strong>。什么都不渲染。（主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li>
</ul>
<p><code>render()</code> 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。如需与浏览器进行交互，请在 <code>componentDidMount()</code> 或其他生命周期方法中执行你的操作。</p>
<hr>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor( )"></a>constructor( )</h1><p><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p>
<p>在 React 组件挂载之前，会调用它的构造函数。在为 <code>React.Component</code> 子类实现构造函数时，应在其他语句之前前调用 <code>super(props)</code>。</p>
<p>通常，在 React 中，构造函数仅用于以下两种情况：</p>
<ul>
<li>通过给 <code>this.state</code> 赋值对象来初始化<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">内部 state</a>。</li>
<li>为<a href="https://zh-hans.reactjs.org/docs/handling-events.html" target="_blank" rel="noopener">事件处理函数</a>绑定实例，如<code>this.handleClick = this.handleClick.bind(this)</code>。</li>
</ul>
<p>在 <code>constructor()</code> 函数中<strong>不要调用 <code>setState()</code> 方法</strong>。如果你的组件需要使用内部 <code>state</code>，请直接在构造函数中为 <strong><code>this.state</code> 赋值初始<code>state</code></strong>：</p>
<p>只能在构造函数中直接为 <code>this.state</code> 赋值。如需在其他方法中赋值，你应使用 <code>this.setState()</code>替代。</p>
<p>####避免将 props 的值复制给 state。直接使用<code>this.props.xxx</code>就可以了。</p>
<hr>
<h1 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount( )"></a>componentDidMount( )</h1><p><code>componentDidMount()</code> 会在组件插入 DOM 树后立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>
<p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅</p>
<p>你可以在 <code>componentDidMount()</code> 里<strong>可以直接调用 <code>setState()</code></strong>。它将触发额外渲染<code>re-render</code>，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p>
<hr>
<h1 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate( )"></a>componentDidUpdate( )</h1><pre><code>componentDidUpdate(prevProps, prevState, snapshot)</code></pre><p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</p>
<p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。</p>
<pre><code>componentDidUpdate(prevProps) {
  // 典型用法（不要忘记比较 props）：
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}</code></pre><p>你也可以在 <code>componentDidUpdate()</code> 中<strong>直接调用 <code>setState()</code></strong>，但请注意<strong>它必须被包裹在一个条件语件里</strong>，正如上述的例子那样进行处理，否则会导致死循环。</p>
<hr>
<h1 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount( )"></a>componentWillUnmount( )</h1><p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p>
<p><code>componentWillUnmount()</code> 中<strong>不应调用 <code>setState()</code></strong>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>
<hr>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="https://zh-hans.reactjs.org/docs/react-component.html#rarely-used-lifecycle-methods" target="_blank" rel="noopener"></a></h3></section><nav id="post-nav"><span class="prev"><a href="/this-point/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"></span></nav><section><div id="disqus_thread"><noscript>'Please enable JavaScript to view the'<a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript></div></section><script>(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());</script></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/joe960913" target="_blank" rel="noopener"><i class="fa fa-github"></i></a><p class="small">You still have time</p></div></footer><script>hljs.initHighlightingOnLoad();</script></body></html>